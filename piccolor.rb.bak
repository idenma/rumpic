require 'rumale'
require "csv"
require 'numo/narray'
require './VectorTransformation'
require 'RMagick'
include Numo
include Magick
#æ©Ÿæ¢°å­¦ç¿’èª­ã¿è¾¼ã¿


csvdata = CSV.read("csv/pixel.csv",headers:  true)

row = csvdata[:row_count].count - 1

pixel_samples = Int32.zeros(row + 1,64)

pixel_labels =[]

# pixel_labels = Int32.zeros(row + 1)
# pl =[]

pixelsamplescount = 0
(0..row).each do |first_number|
  (0..63).each do |second_number|
     pixel_samples[first_number, second_number] = (csvdata[first_number][second_number].to_i)
  end
  pixel_labels <<  csvdata[first_number][64].to_i
  pixelsamplescount.next

end

#pl to_a
p pixel_samples
p pixel_labels
#-----------------

encoder = Rumale::Preprocessing::LabelEncoder.new
labels = encoder.fit_transform(pixel_labels) 
#p labels
#-----------------
# ãƒ©ãƒ³ãƒ€ãƒ ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆğŸŒŸ
#model = Rumale::Ensemble::RandomForestClassifier.new(random_seed: 1)

# Kè¿‘å‚æ³•
#model = Rumale::NearestNeighbors::KNeighborsClassifier.new(n_neighbors: 5)

# æ±ºå®šæœ¨
model = Rumale::Tree::DecisionTreeClassifier.new(random_seed: 1)

#ç·šå½¢SVM
# model = Rumale::LinearModel::SVC.new(
  # reg_param: 0.0001,
  # fit_bias: true,
  # max_iter: 3000,
  # random_seed: 1
# )

# ãƒŠã‚¤ãƒ¼ãƒ–ãƒ™ã‚¤ã‚º
#model = Rumale::NaiveBayes::GaussianNB.new

model.fit(pixel_samples, labels)


#æ©Ÿæ¢°å­¦ç¿’æº–å‚™å®Œäº†-------------------------------------

vector_transformation = VectorTransformation.new #ç”»ãƒ‡ãƒ¼ã‚¿ã‚’æ•°å­—ãƒ‡ãƒ¼ã‚¿ã«ã™ã‚‹ã‚¯ãƒ©ã‚¹

#è²¼ã‚Šä»˜ã‘ã‚‹ãƒ‘ãƒ¼ãƒ„çµµã‚’é…åˆ—ã«èª­ã¿è¾¼ã¿-------------------------------------

piccount = Dir.glob("./img/*").count

pastepicarray = []

(0..piccount - 1).each do |num|
  files = "./img/" + num.to_s + ".png"
    image = Image.read(files).first
    pastepicarray  << image
   
end

#pastepicarray.sort!

#çµµã‚’åˆ‡ã‚Šå–ã‚Šã€é…åˆ—ã«å…¥ã‚Œã‚‹-----------------

files = "./originalimage/colorpic.png"
originalimage = Image.read(files).first
puts originalimage.columns
puts originalimage.rows

num = 0 #ãƒ‘ãƒ¼ãƒ„çµµã®å€‹æ•°
picarray = [] #ãƒ‘ãƒ¼ãƒ„çµµã‚’å…¥ã‚Œã‚‹é…åˆ—

col = originalimage.columns / 8 
row = originalimage.rows / 8

puts "col8 = " + col.to_s
puts "row8 = " + row.to_s
  
(0..row -1).each do |y|
 row8 = y * 8  
 (0..col - 1).each do |x|
  col8 = x * 8
  
 

   parts_img = originalimage.crop(col8, row8, 8, 8)
   picarray << parts_img
   num += 1 
 end
end


#æ©Ÿæ¢°å­¦ç¿’ã§çµµã‚’ç•ªå·ã«å¤‰ãˆã‚‹-----------------
picnumber = [] #çµµã®ç•ªå·
(0..num - 1).each do |pic|

samples =vector_transformation.vector_transformation(picarray[pic])
picnumber << model.predict(samples).to_i
end
p picnumber


#æ–°ã—ã„çµµã‚’ä½œã‚Šçµµã‚’è¼‰ã›ã‚‹-----------------
new_img = Image.new(originalimage.columns, originalimage.rows)

num = 0

(0..row -1).each do |y|
 row8 = y * 8  
 (0..col - 1).each do |x|
  col8 = x * 8
  
 
   new_img.composite!(pastepicarray[picnumber[num] ], col8, row8, OverCompositeOp)
   
   num += 1 
 end
end
#çµµã‚’æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿-----------------




new_img.write("./result/"+ ('A'..'Z').to_a.shuffle[0..10].join + ".png")